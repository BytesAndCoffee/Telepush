from datetime import timedelta
import pymysql as sql
from time import sleep
from telepush import Telepush
from dotenv import load_dotenv
import os
load_dotenv()

# Access environment variables
host = os.getenv('DB_HOST')
password = os.getenv('DB_PASSWORD')
token = os.getenv('TOKEN')
chat_id = os.getenv('CHAT_ID')
username = os.getenv('DB_USERNAME')


conn = sql.connect(
    host=host,
    user=username,
    password=password,
    db='znc',
    cursorclass=sql.cursors.DictCursor,
    ssl={'ca': '/etc/ssl/certs/ca-certificates.crt'}
)

tg_last = "SELECT tg_id FROM inbound_log ORDER BY id DESC LIMIT 1;"
with conn.cursor() as cur:
    cur.execute(tg_last)
    conn.commit()
    res = cur.fetchone()
    # print(res['tg_id'])
    tp = Telepush(token, chat_id, res['tg_id'])


try:
    with conn.cursor() as cur:
        while True:
            s = "SELECT * FROM push;"
            cur.execute(s)
            conn.commit()
            res = cur.fetchone()
            rep = tp.fetch()
            if rep is not None:
                for msg in rep:
                    if msg.text.startswith('context'):
                        tokens = msg.text.split()
                        s = '''SELECT * FROM logs WHERE id = %s;'''
                        cur.execute(s, tokens[1])
                        conn.commit()
                        res = cur.fetchone()
                        if res:
                            window = timedelta(minutes=10)
                            start_time = res['created_at'] - window
                            end_time = res['created_at']

                            s = '''SELECT * FROM logs WHERE (created_at BETWEEN %s AND %s) AND `window` = %s;'''
                            cur.execute(s, (start_time, end_time, res['window']))
                            conn.commit()
                            result = cur.fetchall()
                            msg = ''
                            for line in result:
                                msg += f"{line['nick']}: {line['message']} \n"
                            tp.push(msg)
                        else:
                            tp.push('no such message')
                    elif msg.text.startswith('reply'):
                        tokens = msg.text.split()
                        s = '''SELECT * FROM logs WHERE id = %s;'''
                        cur.execute(s, tokens[1])
                        conn.commit()
                        res = cur.fetchone()
                        if res:
                            s = '''INSERT INTO push (user, network, `window`, type, nick, message) VALUES (%s, %s, %s, %s, %s, %s);'''
                            cur.execute(s, (res['user'], res['network'], res['window'], 'msg', res['nick'], ' '.join(tokens[2:])))
                        else:
                            tp.push('no such message')
            if res:
                # print(res['id'])
                chat = (res['window'], res['nick'])
                if chat in tp.chats:
                    if chat != tp.active:
                        tp.active = chat
                    tp.push(f"{res['message']} \nreply: {res['id']}")
                else:
                    tp.add_chat(*chat)
                    tp.push(f"{res['message']} \nreply: {res['id']}")
                s = 'DELETE FROM push WHERE id={};'.format(res['id'])
                cur.execute(s)
                conn.commit()
            else:
                sleep(5)
finally:
    conn.close()
import logging
from typing import Dict, Optional, List, Tuple
from urllib.parse import quote_plus
from json import loads
import requests
from dataclasses import dataclass, field

import reply


@dataclass
class Line:
    msg: str
    nick: Optional[str]


@dataclass
class Chat:
    window: str
    nick: str
    active: bool = True
    history: List[Line] = field(default_factory=list)

    @property
    def query(self) -> bool:
        return self.window.replace('#', '') == self.nick


inactive = Chat('', '')


class Telepush:
    def __init__(self, token: str, chat_id: str, offset: int):
        self.token: str = token
        self.chat_id: str = chat_id
        self.chats: Dict[Tuple[str, str], Chat] = {}
        self._active: Tuple[str, str] = ('', '')
        self.offset: int = offset
        logging.basicConfig(filename='/home/znc/Telepush/telepush.log', level=logging.ERROR)

    @property
    def active(self) -> Tuple[str, str]:
        return self._active

    @active.getter
    def active(self) -> Chat:
        active: Chat
        active = self.chats[self._active] if self._active else inactive
        return active

    @active.setter
    def active(self, chat: Tuple[str, str]):
        if self._active != chat and self._active != ('', ''):
            self.chats[self._active].active = False
        self.chats[chat].active = True
        self._active = chat

    def add_chat(self, window: str, nick: str):
        chat_id = (window, nick)
        self.chats[chat_id] = Chat(window, nick)
        self.active = chat_id

    def send(self, message: str):
        url = f'https://api.telegram.org/bot{self.token}' \
              f'/sendMessage?chat_id={self.chat_id}' \
              f'&text={quote_plus(message)}'

        resp = requests.get(url)
        if not resp.ok:
            logging.error(resp.text)

    # def fetch(self):
    #     url = f'https://api.telegram.org/bot{self.token}/getUpdates?offset={self.offset}'
    #     res = requests.post(url).json()
    #     print(res)
    #     if res['result']:
    #         self.offset = res['result'][-1]['update_id'] + 1
    #         messages: list = []
    #         for msg in res['result']:
    #             messages.append(reply.consume(msg['message'], msg['update_id']))
    #         return messages

    def fetch(self):
        url = f'https://api.telegram.org/bot{self.token}/getUpdates?offset={self.offset}'
        print(url)
        resp = requests.get(url)
        if not resp.ok:
            logging.error(f"HTTP Error {resp.status_code}: {resp.text}")
            return
        res = resp.json()

        
        # Improved error handling
        if not res.get('ok'):
            logging.error(f"Telegram API error: {res.get('description', 'No description provided')}")
            print('check errror log')
            return None
        
        if 'result' in res and res['result']:
            self.offset = res['result'][-1]['update_id'] + 1
            messages = [reply.consume(msg['message'], msg['update_id']) for msg in res['result']]
            return messages
        return None
    
    def push(self, message: str):
        chat = self.active
        composed = f'<{chat.nick}> {message}'
        if not chat.query:
            composed = f'{chat.window}: {composed}'

        self.send(composed)
        self.active.history.append(Line(message, chat.nick))
from dataclasses import dataclass


@dataclass
class Chat:
    first_name: str
    id: int
    last_name: str
    type: str
    username: str


@dataclass
class User:
    first_name: str
    id: int
    is_bot: bool
    language_code: str
    last_name: str
    username: str


@dataclass
class Message:
    chat: Chat
    date: int
    user: User
    message_id: int
    update_id: int
    text: str


def consume(message: dict, update_id: int) -> Message:
    chat = Chat(**message['chat'])
    user = User(**message['from'])
    return Message(
        chat,
        message['date'],
        user,
        message['message_id'],
        update_id,
        message['text']
    )


if __name__ == '__main__':
    import requests
    import config

    url = f'https://api.telegram.org/bot{config.token}/getUpdates'
    res = requests.post(url).json()

    messages: list = []
    for msg in res['result']:
        messages.append(consume(msg['message'], msg['update_id']))
        print(messages[-1].text)
